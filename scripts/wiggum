#!/usr/bin/env bash
#
# Wiggum - Autonomous coding agent loop using OpenCode
#
# Based on the Ralph Wiggum technique by Geoffrey Huntley
# https://ghuntley.com/ralph/
#
# MODES:
#
#   Plan mode (default):
#     wiggum [OPTIONS] [PLAN_FILE]
#     Uses a plan file with checkboxes. Exits when all [ ] become [x].
#
#   Promise mode:
#     wiggum [OPTIONS] --prompt "your task" --promise "DONE"
#     Uses a prompt string. Exits when Claude outputs <promise>DONE</promise>.
#
# OPTIONS:
#   -a, --auto           Auto-continue without confirmation
#   -m, --max N          Maximum iterations (default: unlimited)
#   --prompt TEXT        Task prompt (enables promise mode)
#   --promise TEXT       Completion signal (default in promise mode: DONE)
#   -h, --help           Show this help
#
# EXAMPLES:
#   wiggum PLAN.md                                    # Plan mode, interactive
#   wiggum --auto --max 20 PLAN.md                    # Plan mode, autonomous
#   wiggum --prompt "Fix all lint errors"             # Promise mode
#   wiggum --auto --prompt "Make tests pass" --promise "TESTS_PASS"
#
# Philosophy:
#   - Failures are data: each failure teaches what guardrails to add
#   - Add signs when Ralph fails: "SLIDE DOWN, DON'T JUMP"
#   - Persistence wins: keep iterating until success
#
# Stop with Ctrl+C. Review commits before pushing.

set -euo pipefail

AUTO_MODE=false
MAX_ITERATIONS=0
PLAN_FILE="PLAN.md"
TASK_PROMPT=""
COMPLETION_PROMISE=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--auto)
            AUTO_MODE=true
            shift
            ;;
        -m|--max)
            MAX_ITERATIONS="$2"
            shift 2
            ;;
        --prompt)
            TASK_PROMPT="$2"
            shift 2
            ;;
        --promise)
            COMPLETION_PROMISE="$2"
            shift 2
            ;;
        -h|--help)
            head -38 "$0" | tail -36
            exit 0
            ;;
        *)
            PLAN_FILE="$1"
            shift
            ;;
    esac
done

# Determine mode
if [[ -n "$TASK_PROMPT" ]]; then
    MODE="promise"
    # Default promise if not specified
    if [[ -z "$COMPLETION_PROMISE" ]]; then
        COMPLETION_PROMISE="DONE"
    fi
else
    MODE="plan"
    if [[ ! -f "$PLAN_FILE" ]]; then
        echo "Error: Plan file '$PLAN_FILE' not found."
        echo "Create a plan first with: amp 'create a plan for ...'"
        echo "Or use promise mode: wiggum --prompt 'your task'"
        exit 1
    fi
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Plan mode functions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

tasks_remaining() {
    grep -qE '^\s*-?\s*\[ \]' "$PLAN_FILE" 2>/dev/null
}

count_remaining() {
    local count
    count=$(grep -cE '^\s*-?\s*\[ \]' "$PLAN_FILE" 2>/dev/null) || true
    echo "${count:-0}"
}

count_completed() {
    local count
    count=$(grep -cE '^\s*-?\s*\[x\]' "$PLAN_FILE" 2>/dev/null) || true
    echo "${count:-0}"
}

build_plan_prompt() {
    cat <<EOF
READ $PLAN_FILE completely. Understand the full context before acting.

RULES:
- Pick exactly ONE unchecked task ([ ]) from the plan
- Complete that task fully
- Verify your work: run tests, typecheck, lint as applicable
- Mark the task as done in $PLAN_FILE with [x]
- Add a brief summary line below the completed task (indented with >)
- Commit the change with a descriptive message
- NEVER git push

COMPLETION FORMAT:
When marking a task done, add a summary line below it:
\`\`\`
- [x] Original task description
  > What was done: files changed, approach taken, any gotchas
\`\`\`

UPDATING THE PLAN ($PLAN_FILE):
If during execution you discover:
- A task is more complex than expected â†’ split it into subtasks
- A task is blocked by something not in the plan â†’ add the blocker as a new task before it
- A task is unnecessary or already done â†’ mark it [x] with a note explaining why
- New tasks are needed â†’ add them in the appropriate place
- The order needs to change â†’ reorder tasks
Keep the plan accurate to reality. The plan is a living document.

UPDATING AGENTS.md:
If you discover critical operational details (build commands, environment setup, gotchas, patterns that work), add them to AGENTS.md so future iterations benefit.

AFTER COMPLETING THE TASK:
- Output a summary block:
  \`\`\`
  â”€â”€ Task Complete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Task: <the task you completed>
  Done: <brief summary of what was done>
  Files: <list of files changed>
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  \`\`\`
- Exit cleanly
- Do not start another task

If all tasks are already complete, say "All tasks complete" and exit.
EOF
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Promise mode functions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

build_promise_prompt() {
    cat <<EOF
$TASK_PROMPT

RULES:
- Work on this task iteratively
- Verify your work: run tests, typecheck, lint as applicable
- Commit changes with descriptive messages
- NEVER git push

UPDATING AGENTS.md:
If you discover critical operational details (build commands, environment setup, gotchas, patterns that work), add them to AGENTS.md so future iterations benefit.

COMPLETION:
When the task is fully complete and verified, output exactly:
<promise>$COMPLETION_PROMISE</promise>

Only output the promise when you are confident the task is done.
If more work is needed, exit without the promise and you will be called again.

AFTER EACH ITERATION:
- Output a summary block:
  \`\`\`
  â”€â”€ Progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Done: <what you accomplished this iteration>
  Remaining: <what still needs to be done, or "nothing - complete">
  Files: <list of files changed>
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  \`\`\`
EOF
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main loop
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Build prompt based on mode
if [[ "$MODE" == "plan" ]]; then
    PROMPT=$(build_plan_prompt)
else
    PROMPT=$(build_promise_prompt)
fi

# Header
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ðŸ” Wiggum Loop"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
if [[ "$MODE" == "plan" ]]; then
    echo "   Mode: plan"
    echo "   Plan: $PLAN_FILE"
    echo "   Tasks: $(count_completed) done, $(count_remaining) remaining"
else
    echo "   Mode: promise"
    echo "   Task: $TASK_PROMPT"
    echo "   Promise: $COMPLETION_PROMISE"
fi
echo "   Auto: $(if [[ "$AUTO_MODE" == true ]]; then echo "yes"; else echo "no (confirm each iteration)"; fi)"
if [[ $MAX_ITERATIONS -gt 0 ]]; then
    echo "   Max iterations: $MAX_ITERATIONS"
fi
echo ""
echo "   Press Ctrl+C to stop"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

ITERATION=0

while true; do
    ITERATION=$((ITERATION + 1))
    
    # Check max iterations
    if [[ $MAX_ITERATIONS -gt 0 && $ITERATION -gt $MAX_ITERATIONS ]]; then
        echo ""
        echo "âš ï¸  Reached maximum iterations ($MAX_ITERATIONS)"
        if [[ "$MODE" == "plan" ]]; then
            echo "   $(count_completed) tasks completed, $(count_remaining) remaining"
        fi
        echo "   Review progress and resume when ready"
        exit 1
    fi
    
    # Plan mode: check if tasks remain before running
    if [[ "$MODE" == "plan" ]] && ! tasks_remaining; then
        echo ""
        echo "âœ… All tasks in $PLAN_FILE are complete!"
        echo "   Review commits with: git log --oneline"
        echo "   Push when ready with: git push"
        exit 0
    fi
    
    # Show iteration header
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    if [[ "$MODE" == "plan" ]]; then
        DONE=$(count_completed)
        TODO=$(count_remaining)
        TOTAL=$((DONE + TODO))
        echo "ðŸš€ $(date '+%H:%M:%S') - Iteration $ITERATION ($DONE/$TOTAL done)"
    else
        echo "ðŸš€ $(date '+%H:%M:%S') - Iteration $ITERATION"
    fi
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # Run OpenCode (streams output in real-time)
    if [[ "$MODE" == "promise" ]]; then
        # Promise mode: capture output while streaming to check for completion signal
        TEMP_OUTPUT=$(mktemp)
        opencode run "$PROMPT" 2>&1 | tee "$TEMP_OUTPUT" || true
        LAST_OUTPUT=$(cat "$TEMP_OUTPUT")
        rm -f "$TEMP_OUTPUT"
        
        # Check for completion promise
        if [[ "$LAST_OUTPUT" == *"<promise>$COMPLETION_PROMISE</promise>"* ]]; then
            echo ""
            echo "âœ… Promise received: $COMPLETION_PROMISE"
            echo "   Review commits with: git log --oneline"
            echo "   Push when ready with: git push"
            exit 0
        fi
    else
        # Plan mode: stream output, no need to capture
        opencode run "$PROMPT" || true
    fi
    
    # Plan mode: check if tasks remain after running
    if [[ "$MODE" == "plan" ]] && ! tasks_remaining; then
        echo ""
        echo "âœ… All tasks in $PLAN_FILE are complete!"
        echo "   Review commits with: git log --oneline"
        echo "   Push when ready with: git push"
        exit 0
    fi
    
    # Ask for confirmation unless in auto mode
    if [[ "$AUTO_MODE" == false ]]; then
        echo ""
        read -p "Continue to next iteration? [Y/n/q] " -n 1 -r REPLY
        echo ""
        case $REPLY in
            [Nn])
                echo "Paused. Resume when ready."
                exit 0
                ;;
            [Qq])
                if [[ "$MODE" == "plan" ]]; then
                    echo "Quit. $(count_completed) tasks completed, $(count_remaining) remaining."
                else
                    echo "Quit after $ITERATION iterations."
                fi
                exit 0
                ;;
        esac
    else
        echo ""
        if [[ "$MODE" == "plan" ]]; then
            echo "ðŸ’¤ Next iteration in 3s... ($(count_remaining) tasks remaining)"
        else
            echo "ðŸ’¤ Next iteration in 3s..."
        fi
        sleep 3
    fi
done
